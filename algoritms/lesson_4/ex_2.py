# Написать два алгоритма нахождения i-го по счёту простого числа. Функция нахождения простого числа должна принимать
# на вход натуральное и возвращать соответствующее простое число. Проанализировать скорость и сложность алгоритмов.
# Первый — с помощью алгоритма «Решето Эратосфена».
# Примечание. Алгоритм «Решето Эратосфена» разбирался на одном из прошлых уроков. Используйте этот код и попробуйте его улучшить/оптимизировать под задачу.
# Второй — без использования «Решета Эратосфена».
# Примечание. Вспомните классический способ проверки числа на простоту.
# Пример работы программ:
# >>> sieve(2)
# 3
# >>> prime(4)
# 7
# >>> sieve(5)
# 11
# >>> prime(1)
# 2
# Примечание по профилированию кода: для получения достоверных результатов при замере времени необходимо
# исключить/заменить функции print() и input() в анализируемом коде. С ними вы будете замерять время вывода данных в
# терминал и время, потраченное пользователем, на ввод данных, а не быстродействие самого алгоритма.

import math
import cProfile


def sieve(n):
    eratos = list(range(n + 1))
    eratos[1] = 0  # без этой строки итоговый список будет содержать единицу
    for i in eratos:
        if i > 1:
            for j in range(i + i, len(eratos), i):
                eratos[j] = 0


def prime(n):
    l = set()
    for i in range(n):
        for j in range(2, 1 + int(math.sqrt(i))):
            if not i % j:
                break
        else:
            l.add(i)


# cProfile.run("sieve(2)")
# 1    0.000    0.000    0.000    0.000 ex_2.py:24(sieve)
# cProfile.run("prime(4)")
# 1    0.000    0.000    0.000    0.000 ex_2.py:33(prime)

cProfile.run("sieve(5)")
# 1    0.000    0.000    0.000    0.000 ex_2.py:24(sieve)
cProfile.run("prime(1)")
# 1    0.000    0.000    0.000    0.000 ex_2.py:33(prime)

